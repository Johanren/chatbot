const fs = require('fs');
const path = require('path');
const express = require('express');
const { createBot, createProvider, createFlow, addKeyword, EVENTS, media, addAnswer, MemoryDB } = require('@bot-whatsapp/bot');
const QRPortalWeb = require('@bot-whatsapp/portal')
const WebWhatsappProvider = require('@bot-whatsapp/provider/web-whatsapp');
const MockAdapter = require('@bot-whatsapp/database/mock');

const TIMEOUT_INACTIVIDAD = 10 * 60 * 1000; // 10 minutos
const sesiones = new Map();
const temporizadores = new Map();

const { useMultiFileAuthState, makeWASocket, DisconnectReason, delay } = require('@whiskeysockets/baileys');
const qrcode = require('qrcode-terminal');
const qrcode1 = require('qrcode');

const sessions = ['asesor1']; // Agrega m√°s sesiones si deseas
const socks = {}; // Mapa global de sesiones: { cliente1: sock1, cliente2: sock2 }

async function startAllSessions() {
    for (const name of sessions) {
        await startWhatsAppSession(name);
    }
}

async function startWhatsAppSession(sessionName) {
    const { state, saveCreds } = await useMultiFileAuthState(`./auth/${sessionName}`);

    const sock = makeWASocket({
        auth: state,
        printQRInTerminal: true,
    });

    socks[sessionName] = sock; // Guardar socket por sesi√≥n

    sock.ev.on('creds.update', saveCreds);

    sock.ev.on('connection.update', (update) => {
        const { connection, lastDisconnect, qr } = update;

        if (qr) {
            console.log(`üì≤ [${sessionName}] Escanea este c√≥digo QR para conectar tu bot:`);
            qrcode.generate(qr, { small: true });
        }

        if (connection === 'close') {
            const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
            console.log(`‚ùå [${sessionName}] Conexi√≥n cerrada`, shouldReconnect ? "‚Üí Intentando reconectar..." : "‚Üí Sesi√≥n cerrada permanentemente.");

            if (shouldReconnect) {
                startWhatsAppSession(sessionName);
            } else {
                console.log(`‚ö† [${sessionName}] Debes volver a escanear el c√≥digo QR.`);
            }
        } else if (connection === 'open') {
            console.log(`‚úÖ [${sessionName}] Conectado a WhatsApp`);
        }
    });
}

async function enviarMensajeWhatsApp(sessionName, usuario, mensaje) {
    const sock = socks[sessionName];
    if (!sock) {
        console.error(`‚ö†Ô∏è Error: la sesi√≥n "${sessionName}" no est√° inicializada.`);
        return;
    }

    try {
        console.log(`üöÄ Enviando desde [${sessionName}] ‚Üí Usuario: ${usuario}, Mensaje: "${mensaje}"`);
        await sock.sendMessage(`${usuario}@s.whatsapp.net`, { text: mensaje });
        console.log("‚úÖ Mensaje enviado correctamente.");
    } catch (error) {
        console.error("‚ùå Error al enviar mensaje:", error);
    }
}

// Iniciar todas las sesiones
startAllSessions();

/*Conexion con pagina web*/

const WebSocket = require('ws');
const ws = new WebSocket('ws://localhost:3000');
//const ws = new WebSocket('wss://3b59-2803-e5e3-2810-7900-1862-447a-ad19-e93.ngrok-free.app');
ws.on('open', () => {
    console.log("üì° Conectado al servidor Web");
});

ws.on('open', () => {
    console.log("üì° Conectado al servidor WebSocket");
});

ws.on('error', (error) => {
    console.error("‚ùå Error en WebSocket:", error);
});

const enviarMensajeWeb = (usuario, asesor, mensaje) => {
    if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ tipo: 'nuevoMensaje', usuario, asesor, mensaje }));
    } else {
        console.warn("‚ö†Ô∏è No se pudo enviar el mensaje: WebSocket no est√° conectado.");
    }
};

const setEstadoUsuario = (user, estado) => {
    sesiones.set(user, estado);
    reiniciarTemporizador(user);
};

const getEstadoUsuario = (user) => sesiones.get(user);

const limpiarEstadoUsuario = (user) => {
    sesiones.delete(user);
    if (temporizadores.has(user)) {
        clearTimeout(temporizadores.get(user));
        temporizadores.delete(user);
    }
};

const reiniciarTemporizador = (user) => {
    if (temporizadores.has(user)) {
        clearTimeout(temporizadores.get(user));
    }

    const timer = setTimeout(async () => {
        let sesion = sesiones.get(user); // Obtener la sesi√≥n del usuario

        // Validar si la sesi√≥n existe
        if (!sesion) {
            console.error(`‚ùå Error: No existe sesi√≥n para el usuario ${user}. Se crear√° una temporal.`);
            sesion = {
                esperandoAsesor: false, // Valor por defecto
                sendMessage: (msg) => {
                    console.log(`Mensaje a ${user}: ${msg}`);
                }
            };
            sesiones.set(user, sesion); // Guardar la nueva sesi√≥n
        }

        // Validar si la sesi√≥n tiene el m√©todo sendMessage
        if (typeof sesion.sendMessage !== "function") {
            console.error(`‚ùå Error: La sesi√≥n para el usuario ${user} no tiene sendMessage. Se crear√°.`);
            sesion.sendMessage = (msg) => {
                console.log(`Mensaje a ${user}: ${msg}`);
            };
            sesiones.set(user, sesion); // Actualizar la sesi√≥n
        }

        sesion.sendMessage("‚è≥ Has estado inactivo por m√°s de 10 minutos. Se cerrar√° la sesi√≥n.");

        // Si el usuario est√° esperando un asesor, notificar al sistema web
        if (sesion.esperandoAsesor) {
            console.log("Sesi√≥n terminada por inactividad del usuario.");
            enviarMensajeWeb(user, "asesor1", "Sesi√≥n terminada por inactividad del usuario");
            limpiarEstadoUsuario(user);
            sesiones.delete(user); // Eliminar la sesi√≥n del mapa
            return;
        }

        // Limpiar estado del usuario y cerrar sesi√≥n
        limpiarEstadoUsuario(user);
        sesiones.delete(user); // Eliminar la sesi√≥n del mapa

    }, TIMEOUT_INACTIVIDAD);

    temporizadores.set(user, timer);
};

ws.onmessage = (event) => {
    try {
        const data = JSON.parse(event.data);

        if (data.tipo === "actualizarWeb") {
            // Verificar si data.chatsWeb es un objeto v√°lido
            if (typeof data.chatsWeb !== 'object' || data.chatsWeb === null) {
                console.error("‚ùå Error: data.chatsWeb no es un objeto v√°lido", data.chatsWeb);
                return;
            }
            // Recorrer los usuarios y obtener solo el √∫ltimo mensaje
            Object.entries(data.chatsWeb).forEach(([usuario, mensajes]) => {
                if (!Array.isArray(mensajes) || mensajes.length === 0) {
                    console.error(`‚ùå Error: No hay mensajes v√°lidos para el usuario ${usuario}`, mensajes);
                    return;
                }
                // Obtener el √∫ltimo mensaje del array
                const ultimoMensaje = mensajes[mensajes.length - 1];
                const asesor = ultimoMensaje.asesor || "asesor_desconocido"; // fallback si no viene asesor

                console.log(`‚úâÔ∏è Enviando √∫ltimo mensaje a ${usuario}: "${ultimoMensaje.mensaje}" desde el Asesor: ${asesor}`);
                enviarMensajeWhatsApp(asesor, usuario, ultimoMensaje.mensaje);
            });
        }
    } catch (error) {
        console.error("‚ùå Error al procesar el mensaje WebSocket:", error);
    }
};


/*Flujo Principal*/

const flowPrincipalAsesor = addKeyword(EVENTS.WELCOME)
    .addAction(async (ctx, { gotoFlow }) => {
        const usuarioID = ctx.from;
        const mensaje = ctx.body.trim();
        const estado = getEstadoUsuario(ctx.from);

        // Si el usuario est√° esperando un asesor, bloquea el flujo principal
        if (estado?.esperandoAsesor) {
            console.log("üîí Actualmente est√°s esperando a un asesor. No se ejecutar√° el flujo principal.");
            await console.log("üì© *Puedes seguir enviando mensajes. Un asesor te responder√° pronto.*");
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return;  // No hace nada, evitando el flujo
        }

        // Si no est√° esperando un asesor, continuar con el flujo principal
        return gotoFlow(flowPrincipal);
    });



const flowPrincipal = addKeyword(EVENTS.WELCOME)
    .addAnswer('¬°Aqu√≠ tienes una imagen!', { media: 'c:/xampp/htdocs/chatbot/public/img/logo.png' })
    .addAnswer("üëã ¬°Hola! Bienvenido al asistente virtual de *Jordel Ingenier√≠a SAS, FiberNet*.", {}, async (ctx, { gotoFlow, flowDynamic }) => {
        return gotoFlow(flowMenuPrincipal);
    });

const flowMenuPrincipal = addKeyword(EVENTS.ACTION)
    .addAnswer([
        "üëá *Seleccione una opci√≥n:*",
        "1Ô∏è‚É£ Consulta de Servicio",
        "2Ô∏è‚É£ Facturaci√≥n y Pagos",
        "3Ô∏è‚É£ Planes y Promociones",
        "4Ô∏è‚É£ Soporte T√©cnico Avanzado",
        "5Ô∏è‚É£ Consulta Personalizada",
        "6Ô∏è‚É£ Asistencia en Tiempo Real",
        "7Ô∏è‚É£ Comentarios y Sugerencias",
        "8Ô∏è‚É£ Informaci√≥n General",
        "‚úñÔ∏è Escribe *cerrar sesi√≥n* para salir.",
        "*Escribe el n√∫mero de la opci√≥n que deseas.*"
    ], { capture: true }, async (ctx, { flowDynamic, gotoFlow }) => {
        setEstadoUsuario(ctx.from, { menu: "principal", sendMessage: flowDynamic });
        const seleccion = ctx.body.trim();
        if (seleccion === "Cerrar sesi√≥n") return gotoFlow(flowCerrarSesion);
        switch (seleccion) {
            case "1": return gotoFlow(flowConsultaServicio);
            case "2": return gotoFlow(flowFacturacionPagos);
            case "3": return gotoFlow(flowPlanesPromociones);
            case "4": return gotoFlow(flowSoporteTecnico);
            case "5": return gotoFlow(flowConsultaPersonalizada);
            case "6": return gotoFlow(flowAsistenciaTiendoReal);
            case "7": return gotoFlow(flowComentarioSugerencia);
            case "8": return gotoFlow(flowInformacionGeneral);
            default: return flowDynamic("‚ö†Ô∏è Opci√≥n no v√°lida. Intente nuevamente.") + gotoFlow(flowMenuPrincipal);
        }
    });

/*Cierre Sesion*/

const flowCerrarSesion = addKeyword("cerrar sesi√≥n")
    .addAnswer("üîí ¬øSeguro que quieres cerrar sesi√≥n? Escribe *s√≠* o *no*.",
        { capture: true }, async (ctx, { flowDynamic, gotoFlow }) => {
            if (ctx.body.trim().toLowerCase() === "si" || ctx.body.trim().toLowerCase() === "Si") {
                limpiarEstadoUsuario(ctx.from);
                return flowDynamic("‚úÖ Has cerrado sesi√≥n. Escribe *hola* para volver a activarlo.");
            }
            flowDynamic("üîô Regresando al men√∫ principal...");
            await new Promise(resolve => setTimeout(resolve, 1000)); // Espera 1 segundo antes de ir al flujo
            return gotoFlow(flowMenuPrincipal)
        });

const flowVolverMenuPrincipal = addKeyword(["9"])
    .addAnswer("üîô Regresando al men√∫ principal...", {}, async (ctx, { flowDynamic, gotoFlow }) => {
        await new Promise(resolve => setTimeout(resolve, 1000)); // Espera 1 segundo antes de ir al flujo
        return gotoFlow(flowMenuPrincipal);
    });

const flowCerrarConversacion = addKeyword(["0"])
    .addAnswer("‚úÖ *Conversaci√≥n cerrada.*", {}, async (ctx, { flowDynamic, gotoFlow }) => {
        const estado = getEstadoUsuario(ctx.from);
        if (estado?.esperandoAsesor) {
            const usuarioID = ctx.from;
            let mensaje = "Conversacion terminada por el cliente";
            console.log("Conversacion terminda");
            await console.log("üì© *Puedes seguir enviando mensajes. Un asesor te responder√° pronto.*");
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            limpiarEstadoUsuario(usuarioID);
            return gotoFlow(flowMenuPrincipal);  // No hace nada, evitando el flujo
        }
        await new Promise(resolve => setTimeout(resolve, 1000)); // Espera 1 segundo antes de ir al flujo
        return gotoFlow(flowMenuPrincipal);
    });


/*Sub Menus*/

const flowConsultaServicio = addKeyword(EVENTS.ACTION)
    .addAnswer([
        "üëá *Seleccione una opci√≥n:*",
        "1Ô∏è‚É£üì° Estado de mi conexi√≥n",
        "2Ô∏è‚É£üîß Problemas t√©cnicos",
        "3Ô∏è‚É£üìÖ Mantenimiento programado",
        "9Ô∏è‚É£ Volver al men√∫ principal"
    ], { capture: true }, async (ctx, { flowDynamic, gotoFlow }) => {
        const usuarioID = ctx.from;
        const seleccion = ctx.body.trim();
        /*const respuestas = {
            "1": "üì° Tu conexi√≥n est√° funcionando correctamente.",
            "2": "üîß Puedes contactar a soporte t√©cnico al 123-456-7890.",
            "3": "üìÖ No hay mantenimientos programados en este momento.",
        };*/
        if (seleccion === "9") return gotoFlow(flowVolverMenuPrincipal);

        // Respuestas seg√∫n opci√≥n seleccionada
        if (seleccion === "1") {
            let mensaje = "Cliente busca ayuda en Estado de mi conexi√≥n";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }

        if (seleccion === "2") {
            let mensaje = "Cliente busca ayuda en Problemas t√©cnicos";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }
        if (seleccion === "3") {
            let mensaje = "Cliente busca ayuda en Mantenimiento programado";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }
        //await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
        //await new Promise(resolve => setTimeout(resolve, 20000)); // 20 segundos de espera
        // Opci√≥n no v√°lida
        await flowDynamic("‚ö†Ô∏è Opci√≥n no v√°lida. Intente nuevamente.");
        return gotoFlow(flowConsultaServicio);
    });

const flowFacturacionPagos = addKeyword(EVENTS.ACTION)
    .addAnswer([
        "üëá *Facturaci√≥n y Pagos:*",
        "1Ô∏è‚É£üí∞ Consultar saldo",
        "2Ô∏è‚É£üí≥ Realizar un pago",
        "3Ô∏è‚É£üìú Historial de facturaci√≥n",
        "9Ô∏è‚É£ Volver al men√∫ principal"
    ], { capture: true }, async (ctx, { flowDynamic, gotoFlow }) => {
        const usuarioID = ctx.from;
        const seleccion = ctx.body.trim();
        /*const respuestas = {
            "1": "üí∞ Tu saldo es de $50,000 COP.",
            "2": "üí≥ Puedes realizar un pago en nuestra plataforma.",
            "3": "üìú Aqu√≠ est√° tu historial de pagos.",
        };*/
        // Respuestas seg√∫n opci√≥n seleccionada

        if (seleccion === "9") return gotoFlow(flowVolverMenuPrincipal);

        if (seleccion === "1") {
            let mensaje = "Cliente busca ayuda en Consultar saldo";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }

        if (seleccion === "2") {
            let mensaje = "Cliente busca ayuda en Realizar un pago";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }
        if (seleccion === "3") {
            let mensaje = "Cliente busca ayuda en Historial de facturaci√≥n";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }
        /*await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
        await new Promise(resolve => setTimeout(resolve, 20000)); // 20 segundos de espera*/
        // Opci√≥n no v√°lida
        await flowDynamic("‚ö†Ô∏è Opci√≥n no v√°lida. Intente nuevamente.");
        return gotoFlow(flowFacturacionPagos);
    });

const flowPlanesPromociones = addKeyword(EVENTS.ACTION)
    .addAnswer([
        "üëá *Planes y Promociones:*",
        "1Ô∏è‚É£üìÑ Explorar planes",
        "2Ô∏è‚É£üî• Promociones actuales",
        "3Ô∏è‚É£üîÑ Cambio de plan",
        "9Ô∏è‚É£ Volver al men√∫ principal"
    ], { capture: true }, async (ctx, { flowDynamic, gotoFlow }) => {
        const usuarioID = ctx.from;
        const seleccion = ctx.body.trim();
        /*const respuestas = {
            "1": "üìÑ Planes de hasta 1 Gbps disponibles.",
            "2": "üî• 10% de descuento en nuevos suscriptores.",
            "3": "üîÑ Contacta a un asesor para cambiar de plan."
        };*/
        // Respuestas seg√∫n opci√≥n seleccionada

        if (seleccion === "9") return gotoFlow(flowVolverMenuPrincipal);


        if (seleccion === "1") {
            await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
            await new Promise(resolve => setTimeout(resolve, 5000)); // 5 segundos de espera
            try {
                await flowDynamic([{ body: ' ', media: 'c:/xampp/htdocs/chatbot/public/img/uno.jpg', delay: 1000 }]);
                await flowDynamic([{ body: ' ', media: 'c:/xampp/htdocs/chatbot/public/img/dos.jpg', delay: 1000 }]);
                await flowDynamic([{ body: ' ', media: 'c:/xampp/htdocs/chatbot/public/img/tres.jpg', delay: 1000 }]);
                await flowDynamic([{ body: ' ', media: 'c:/xampp/htdocs/chatbot/public/img/cuatro.jpg', delay: 1000 }]);
                await flowDynamic([{ body: ' ', media: 'c:/xampp/htdocs/chatbot/public/img/cinco.jpg', delay: 1000 }]);
                await flowDynamic([{ body: ' ', media: 'c:/xampp/htdocs/chatbot/public/img/seis.jpg', delay: 1000 }]);
                await flowDynamic([{ body: ' ', media: 'c:/xampp/htdocs/chatbot/public/img/siete.jpg', delay: 1000 }]);
            } catch (error) {
                console.error('Error en flowDynamic:', error);
            }

        }

        if (seleccion === "2") {
            //await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
            //await new Promise(resolve => setTimeout(resolve, 5000)); // 5 segundos de 
            let mensaje = "Cliente busca ayuda en Promociones actuales";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }
        if (seleccion === "3") {
            await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
            await new Promise(resolve => setTimeout(resolve, 5000)); // 5 segundos de espera
            await flowDynamic("Haz Tu Cambio de plan aqu√≠ üëâ https://forms.gle/VFrnbvWzZYydiD4q6")
        }
        // Opci√≥n no v√°lida
        if (!["9", "1", "2", "3"].includes(seleccion)) {
            await flowDynamic("‚ö†Ô∏è Opci√≥n no v√°lida. Intente nuevamente.");
            return gotoFlow(flowComentarioSugerencia);
        }
    });

const flowSoporteTecnico = addKeyword(EVENTS.ACTION)
    .addAnswer([
        "üëá *Soporte T√©cnico Avanzado:*",
        "1Ô∏è‚É£üîç Diagn√≥stico de red",
        "2Ô∏è‚É£‚öôÔ∏è Configuraci√≥n avanzada",
        "3Ô∏è‚É£üìû Contactar a un t√©cnico",
        "9Ô∏è‚É£ Volver al men√∫ principal"
    ], { capture: true }, async (ctx, { flowDynamic, gotoFlow }) => {
        const usuarioID = ctx.from;
        const seleccion = ctx.body.trim();
        /*const respuestas = {
            "1": "üîç Realiza un diagn√≥stico de red en nuestra app.",
            "2": "‚öôÔ∏è Consulta nuestra gu√≠a de configuraci√≥n avanzada.",
            "3": "üìû Llama al 123-456-7890 para soporte t√©cnico."
        };*/
        if (seleccion === "9") return gotoFlow(flowVolverMenuPrincipal);

        if (seleccion === "1") {
            let mensaje = "Cliente busca ayuda en Diagn√≥stico de red";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }

        if (seleccion === "2") {
            let mensaje = "Cliente busca ayuda en Configuraci√≥n avanzada";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }
        if (seleccion === "3") {
            let mensaje = "Cliente busca ayuda en Contactar a un t√©cnico";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }
        /*await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
        await new Promise(resolve => setTimeout(resolve, 20000)); // 20 segundos de espera*/
        // Opci√≥n no v√°lida
        await flowDynamic("‚ö†Ô∏è Opci√≥n no v√°lida. Intente nuevamente.");
        return gotoFlow(flowSoporteTecnico);
    });

const flowConsultaPersonalizada = addKeyword(EVENTS.ACTION)
    .addAnswer([
        "üëá *Consulta Personalizada:*",
        "1Ô∏è‚É£ Asistente inteligente",
        "2Ô∏è‚É£ Sugerencias basadas en historial",
        "9Ô∏è‚É£ Volver al men√∫ principal"
    ], { capture: true }, async (ctx, { flowDynamic, gotoFlow }) => {
        const usuarioID = ctx.from;
        const seleccion = ctx.body.trim();
        /*const respuestas = {
            "1": " Describe tu problema o consulta y recibir√°s una respuesta personalizada",
            "2": " Si has interactuado antes, puedo ofrecerte soluciones basadas en tus consultas pasadas."
        };*/
        if (seleccion === "9") return gotoFlow(flowVolverMenuPrincipal);

        if (seleccion === "1") {
            let mensaje = "Cliente busca ayuda en Asistente inteligente";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }

        if (seleccion === "2") {
            let mensaje = "Cliente busca ayuda en Sugerencias basadas en historial";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }
        /*await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
        await new Promise(resolve => setTimeout(resolve, 20000)); // 20 segundos de espera*/
        // Opci√≥n no v√°lida
        await flowDynamic("‚ö†Ô∏è Opci√≥n no v√°lida. Intente nuevamente.");
        return gotoFlow(flowConsultaPersonalizada);
    });

const flowAsistenciaTiendoReal = addKeyword(EVENTS.ACTION)
    .addAnswer([
        "üëá *Asistencia en Tiempo Real:*",
        "1Ô∏è‚É£ Hablar con un agente",
        "2Ô∏è‚É£ Programar una llamada",
        "9Ô∏è‚É£ Volver al men√∫ principal"
    ], { capture: true }, async (ctx, { flowDynamic, gotoFlow }) => {
        const usuarioID = ctx.from;
        const seleccion = ctx.body.trim();

        if (seleccion === "9") return gotoFlow(flowVolverMenuPrincipal);

        // Respuestas seg√∫n opci√≥n seleccionada
        if (seleccion === "1") {
            let mensaje = "Cliente busca ayuda en Hablar con un agente";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }

        if (seleccion === "2") {
            let mensaje = "Cliente busca ayuda en Programar una llamada";

            // Enviar mensaje al WebSocket
            enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            return gotoFlow(flowChatAsesor);
        }

        // Opci√≥n no v√°lida
        await flowDynamic("‚ö†Ô∏è Opci√≥n no v√°lida. Intente nuevamente.");
        return gotoFlow(flowAsistenciaTiendoReal);
    });


const flowComentarioSugerencia = addKeyword(EVENTS.ACTION)
    .addAnswer([
        "üëá *Comentarios y Sugerencias:*",
        "1Ô∏è‚É£ Dejar una opini√≥n",
        "2Ô∏è‚É£ Participar en encuestas",
        "9Ô∏è‚É£ Volver al men√∫ principal"
    ], { capture: true }, async (ctx, { flowDynamic, gotoFlow }) => {
        const seleccion = ctx.body.trim();
        /*const respuestas = {
            "1": " Comparte tu experiencia y sugerencias para mejorar.",
            "2": " Ay√∫danos a mejorar nuestros servicios respondiendo a breves encuestas"
        };*/
        if (seleccion === "9") return gotoFlow(flowVolverMenuPrincipal);

        if (seleccion === "1") {
            await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
            await new Promise(resolve => setTimeout(resolve, 5000)); // 5 segundos de espera
            await flowDynamic("Dejanos tu opinion atraves de üëâ https://forms.gle/w3aTL3GhUXxGuh8MA")
        }

        if (seleccion === "2") {
            await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
            await new Promise(resolve => setTimeout(resolve, 5000)); // 5 segundos de espera
            await flowDynamic("Participar en encuestas")
            await flowDynamic("https://forms.gle/VFrnbvWzZYydiD4q6")
        }
        /*await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
        await new Promise(resolve => setTimeout(resolve, 20000)); // 20 segundos de espera*/
        if (!["9", "1", "2", "3"].includes(seleccion)) {
            await flowDynamic("‚ö†Ô∏è Opci√≥n no v√°lida. Intente nuevamente.");
            return gotoFlow(flowComentarioSugerencia);
        }
    });

const flowInformacionGeneral = addKeyword(EVENTS.ACTION)
    .addAnswer([
        "üëá *Informaci√≥n General:*",
        "1Ô∏è‚É£ Preguntas frecuentes",
        "2Ô∏è‚É£ Pol√≠ticas de uso y privacidad",
        "9Ô∏è‚É£ Volver al men√∫ principal"
    ], { capture: true }, async (ctx, { flowDynamic, gotoFlow }) => {
        const seleccion = ctx.body.trim();
        /*const respuestas = {
            "1": " Encuentra respuestas a las preguntas m√°s comunes.",
            "2": " Consulta nuestras pol√≠ticas y t√©rminos."
        };*/
        if (seleccion === "9") return gotoFlow(flowVolverMenuPrincipal);

        if (seleccion === "1") {
            await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
            await new Promise(resolve => setTimeout(resolve, 5000)); // 5 segundos de espera
            flowDynamic("Dejanos tu opinion atraves de üëâ https://forms.gle/w3aTL3GhUXxGuh8MA")
        }

        if (seleccion === "2") {
            await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
            await new Promise(resolve => setTimeout(resolve, 5000)); // 5 segundos de espera
            flowDynamic("Nuestras Politicas de uso y privacidad")
            flowDynamic("En FiberNet")
        }
        /*await flowDynamic("‚è≥ Por favor, espera un momento mientras procesamos tu solicitud...");
        await new Promise(resolve => setTimeout(resolve, 20000)); // 20 segundos de espera*/
        await flowDynamic("‚ö†Ô∏è Opci√≥n no v√°lida. Intente nuevamente.");
        return gotoFlow(flowInformacionGeneral);
    });

/*Hablar con un accesor*/

// Inicializar el objeto global si no existe
if (!global.tiempoInactividad) {
    global.tiempoInactividad = {};
}

const flowChatAsesor = addKeyword(EVENTS.ACTION)
    .addAction(async (ctx, { flowDynamic, gotoFlow }) => {
        const usuarioID = ctx.from;
        let mensaje = ctx.body.trim();

        // Enviar mensaje al WebSocket
        enviarMensajeWeb(usuarioID, "asesor1", mensaje);

        if (mensaje === "0") {
            limpiarEstadoUsuario(usuarioID);
            return gotoFlow(flowMenuPrincipal);
        }

        // Marcar como esperando asesor
        setEstadoUsuario(usuarioID, { esperandoAsesor: true });

        // Respuesta autom√°tica despu√©s de 2 segundos
        setTimeout(async () => {
            await flowDynamic("üëá *En un momento, uno de nuestros asesores se comunicar√° contigo.*");
        }, 2000);

        // Configurar recordatorio de inactividad
        if (global.tiempoInactividad[usuarioID]) {
            clearTimeout(global.tiempoInactividad[usuarioID]);
        }

        global.tiempoInactividad[usuarioID] = setTimeout(async () => {
            const estado = getEstadoUsuario(usuarioID);
            if (estado?.esperandoAsesor) {
                await flowDynamic("‚è≥ Parece que has estado inactivo. Si deseas cerrar la conversaci√≥n, responde con *0Ô∏è‚É£*.");
                mensaje = "Inactividad por el usuario";
                enviarMensajeWeb(usuarioID, "asesor1", mensaje);
            }
        }, 300000); // 5 minutos
    });

// Almacenar temporalmente los QR por bot
const qrStorage = {};

const createInstance = async (nombreBot, sessionId, port) => {
    const sessionFolder = path.join(__dirname, 'sessions', sessionId);
    if (!fs.existsSync(sessionFolder)) {
        fs.mkdirSync(sessionFolder, { recursive: true });
    }

    const adapterDB = new MockAdapter();
    const adapterFlow = createFlow([
        flowPrincipalAsesor, flowPrincipal, flowMenuPrincipal, flowConsultaServicio,
        flowFacturacionPagos, flowPlanesPromociones, flowSoporteTecnico,
        flowConsultaPersonalizada, flowAsistenciaTiendoReal, flowComentarioSugerencia,
        flowInformacionGeneral, flowCerrarSesion, flowVolverMenuPrincipal,
        flowChatAsesor, flowCerrarConversacion
    ]);

    const adapterProvider = createProvider(WebWhatsappProvider, {
        sessionPath: sessionFolder,
    });

    const bot = await createBot({
        flow: adapterFlow,
        provider: adapterProvider,
        database: adapterDB,
    });

    QRPortalWeb({ port });
};

const bots = [
    { nombre: "Bot #1", sessionId: "bot1", port: 3001 }
];

const main = async () => {
    await Promise.all(
        bots.map(bot => createInstance(bot.nombre, bot.sessionId, bot.port))
    );
};

main();
